@inproceedings{ribas2025pain,
  title={Pain in a Safe Space: Temporal Analysis of Discourses in the Womenintech Subreddit},
  author={Jessica Barbara da Silva Ribas and Joanne Carneiro and Theo Sousa and Júlia Azevedo and Jailma Januario da silva and Anderson Uchôa and Juliana Alves Pereira},
  booktitle={Proceedings of the 39th Brazilian Symposium on Software Engineering (SBES), Insightful Ideas and Emerging Results Track, 2025, Recife, Pernambuco, Brazil, September 22--26 2025},
  pages={1--7},
  year={2025},
  abstract={Women in Information Technology (IT) continue to face systemic barriers, including career stagnation, lack of recognition, workplace bias, and professional isolation. In response to these challenges and the absence of female peers with whom to share experiences, external support networks have emerged. One such space is the r/womenintech subreddit, which offers a dedicated and inclusive space for women in tech to exchange experiences, seek advice, and build community. This study investigates the discursive landscape of this subreddit by analyzing 2,367 posts published between April 2024 and April 2025. We applied a set of natural language processing (NLP) techniques, using the Twitter-based RoBERTa model, to conduct a multi-dimensional analysis that includes emotion detection, sentiment analysis, hate speech classification, irony detection, and offensive content identification. Our findings show that 99.9% of the posts are free of hate speech, reinforcing the subreddit’s role as a safe space for women in tech to share experiences. However, the predominance of neutral sentiment (48%) and the prevalence of the emotion Sadness (45%) reveal that the experiences reported are often distressing and unpleasant. In addition, we explore temporal trends in politically charged contexts of DEIA law. Our findings highlight the importance of better understanding the underlying structural and cultural factors that contribute to these emotions and open new directions for further analysis, e.g. including exploring the comments attached to each post.},
}

@inproceedings{gomes2025peacemakerbot,
  title={PeacemakerBot: A LLM-Powered Bot for Identifying and Reducing Signs of Incivility in GitHub Conversations},
  author={Antônio Gomes and Eric Mesquita and Emanuel Ávila and Carlos Jefté and Arthur Mesquita and Lucas Sousa and Matheus Rabelo and Mairieli Wessel and Anderson Uchôa},
  booktitle={Proceedings of the 39th Brazilian Symposium on Software Engineering (SBES), Tools Track, 2025, Recife, Pernambuco, Brazil, September 22--26 2025},
  pages={1--7},
  year={2025},
  abstract={Developers' interactions on collaborative software development platforms like GitHub are key to maintaining technical alignment and community engagement. However, uncivil behaviors such as disrespectful, sarcastic, or offensive comments can undermine these efforts, discouraging contributions and harming code quality. This study introduces PeacemakerBot, an automated moderation tool that detects and warns developers of incivility signs in GitHub conversations. We leverage Large Language Models (LLMs) to analyze conversations, identify signals of incivility, and generate reformulation suggestions in real time. To evaluate it, we conducted a user study with six developers, followed by a survey based on the Technology Acceptance Model (TAM) to understand their perception of the tool's usefulness. Our results suggest that PeacemakerBot successfully identifies multiple types of incivility and promotes more constructive conversations. The moderation feedback loop allows users to revise flagged comments, enhancing awareness and reducing harmful language over time. Our tool fills a key gap in OSS by providing AI-assisted moderation to enhance the social climate and inclusiveness of developer interactions. Video link: https://doi.org/10.5281/zenodo.15486009},
}

@inproceedings{sousa2025diversity,
  title={Diversity Matters: Perceived Inclusion and Discrimination by Brazilian Tech Professionals},
  author={Theo Sousa and Júlia Azevedo and Jessica Barbara da Silva Ribas and Anderson Uchôa and Larissa Rocha Soares Bastos and Juliana Alves Pereira},
  booktitle={Proceedings of the 39th Brazilian Symposium on Software Engineering (SBES), 2025, Recife, Pernambuco, Brazil, September 22--26 2025},
  pages={1--12},
  year={2025},
  abstract={Context: Diversity and inclusion are widely recognized as essential drivers of innovation in software engineering. However, systemic inequalities and implicit biases remain persistent challenges. Goal: This study aims to explore how tech professionals in Brazil perceive inclusion, discrimination, and unconscious bias in the workplace. Method: We surveyed 220 tech professionals, focusing on experiences of bias, perceptions of fairness, and the influence of organizational setting. Results: The findings reveal that 95.2% of women experienced sexism, compared to 70.3% of men; 77.1% of non-white professionals identify racism as a key issue, while 61.5% of disabled professionals report experiencing ableism. Hybrid work models were associated with the highest reports of sexism (80%), while employees at smaller companies reported more frequent instances of ableism than those at larger ones. Despite widespread acknowledgment of discrimination, only 23% of respondents explicitly recognized the presence of unconscious bias in themselves. While most see their teams as diverse, leadership inclusion lags, especially for disabled (25.9%) and neurodivergent (36.4%) professionals. Conclusion: These results reveal persistent equity gaps and call for  DEI (Diversity, Equity, and Inclusion) strategies in Brazil’s tech sector.},
}

@inproceedings{martin2025evaluating,
  title={Evaluating the Potential of Large Language Models in Security-Related Software Requirements Classification},
  author={Murilo Martin and Daniel Coutinho and Anderson Uchôa and Juliana Alves Pereira},
  booktitle={Proceedings of the 39th Brazilian Symposium on Software Engineering (SBES), 2025, Recife, Pernambuco, Brazil, September 22--26 2025},
  pages={1--12},
  year={2025},
  abstract={An effective classification of security-related software requirements is essential to mitigate potential threats and ensure robust system design. This study investigates the accuracy of large language models (LLMs) in classifying security-related requirements compared to traditional machine learning (ML) methods. Using the SecReq and PROMISE+ datasets, we evaluated ten LLMs across various prompt engineering strategies. The results demonstrate that LLMs achieve high accuracy and outperform traditional ML models in several evaluation scenarios and that prompt engineering can significantly enhance the model's ability to identify security-related requirements. This work underscores the domain-generalization capabilities of LLMs and their potential to streamline requirements classification without the complexity of feature engineering or dataset-specific fine-tuning often required by ML approaches. Researchers, practitioners, and tool developers can leverage these findings to advance automated approaches in security requirements engineering.},
}

@inproceedings{uchoa2025clones,
  title={An Exploratory Study on the Lifecycle of Code Clones during Code Review},
  author={Italo Uchoa and Denis Sousa and Matheus Paixão and Pedro Maia and Anderson Uchôa and Chaiyong Ragkhitwetsagul},
  booktitle={Proceedings of the 39th Brazilian Symposium on Software Engineering (SBES), 2025, Recife, Pernambuco, Brazil, September 22--26 2025},
  pages={1--12},
  year={2025},
  abstract={The Modern Code Review (MCR) process is iterative and asynchronous, enabling early identification of several issues during software development. Overall, code review consists of inspecting code before merging it into the codebase. Code clones are code fragments that are copied and reused across different (or the same) codebases, often with minor changes. Developers must be aware of code clones in their projects, as issues in a cloned fragment may cause adjustments in all related clones, which can significantly impact the project's maintainability. Nevertheless, there is still a gap in research addressing the presence and behavior of code clones during code review. By leveraging the CROP dataset (with over 28k code reviews and 80k revisions) and the Siamese clone detector, we identified 27,656 relevant code clones that underwent code review in 6 different software systems. A manual validation of a representative sample indicated a predominance of Type-I (46.74%) and Type-III (45.3%) clones. Based on the clones' lifecycle within the review, we categorized the reviews into Single and Recurring, according to how the clones are introduced and/or removed during the review process. We identified 224 reviews for which clones appear in a single review (Single) and 1,258 reviews for which clones appear in multiple revisions (Recurring). Additionally, 236 code reviews lie at the intersection of Recurring and Single code reviews. To deepen the analysis, we introduced two metrics, Duration and Distance, to assess how clones are introduced or removed during the review. We observed that, on average, clones are often introduced at the beginning of the code review, commonly surviving the review process and being merged into the codebase.},
}

@inproceedings{patricio2025incivility,
  title={404: Civility Not Found? Evaluating the Effectiveness of Small Language Models in Detecting Incivility in GitHub Conversations},
  author={Mario Patrício and Silas Eufrásio and Anderson Uchôa and Lincoln S. Rocha and Daniel Coutinho and Juliana Alves Pereira and Matheus Paixão and Alessandro Garcia},
  booktitle={Proceedings of the 39th Brazilian Symposium on Software Engineering (SBES), 2025, Recife, Pernambuco, Brazil, September 22--26 2025},
  pages={1--12},
  year={2025},
  abstract={Context: Incivility in open-source software (OSS) platforms like GitHub can harm collaboration, discourage contributor participation, and impact code quality. Although current moderation tools based on Machine Learning (ML) and Natural Language Processing (NLP) offer some support, they often struggle to detect nuanced or implicit types of incivility. Goal: This study aims to assess the effectiveness of Small Language Models (SLMs) in detecting both coarse-grained (civil vs. uncivil) and fine-grained (specific types) incivility in GitHub conversations (issues and pull requests), and to understand how different prompting strategies influence detection performance. Method: We evaluate ten SLMs (3B-14B parameters) across five prompt strategies, on a labeled dataset with more than 6k GitHub conversations. We also compare the best-performing SLMs with five traditional ML models using two text-encoding techniques. Results: Our results reveal that SLMs perform well in detecting civil comments, but their effectiveness in detecting uncivil comments depends on model size. Models with 9B+ parameters (e.g., deepseek-r1, gpt-4o-mini) show improved performance on uncivil comments. For the fine-grained granularity, prompting strategy plays a critical role, with role-based prompting achieving the best results, particularly for implicit incivility types (e.g., Irony and Mocking), even when SLMs struggle with these types of incivility. Traditional ML models still perform well in explicit cases like Threat and Insulting. Conclusion: Our findings highlight the effectiveness of SLMs and prompt strategies in enhancing the detection of incivility within collaborative software development settings.},
}

@inproceedings{silva2025aunveiling,
  title={Unveiling the Relationship Between Continuous Integration and Code Review: A Study with 10 Closed-source Projects},
  author={Ruben Silva and Publio Silva and Carla Bezerra and Anderson Uchôa and Alessandro Garcia},
  booktitle={Proceedings of the 39th Brazilian Symposium on Software Engineering (SBES), 2025, Recife, Pernambuco, Brazil, September 22--26 2025},
  pages={1--12},
  year={2025},
  abstract={Companies have adopted Continuous Integration (CI) and Code Review (CR) as key practices to monitor and improve software quality continuously. These practices enable early detection and correction of issues and have shown promising results in open and closed-source projects. However, there is limited understanding of the relationship between CI and CR in closed-source environments. For instance, it remains unclear how CI practices influence CR (and vice versa) and to what extent bad CI practices hinder the CR process. To address this gap, we conducted a mixed-methods study involving ten closed-source projects developed by industry partners. We collected and analyzed 32 metrics related to CI and CR. In addition to the quantitative analysis, we gathered perceptions from project teams to (i) validate the identified correlations, (ii) explore the effects of bad CI practices on CR, and (iii) understand the perceived benefits and challenges of using CI and CR together. Our results revealed 23 correlations between CI and CR processes, leading to the following key findings: (i) the workload and execution time of CI can influence code review time; (ii) CI and CR execution times are more correlated when the processes occur sequentially; (iii) bad CI practices (such as long-lived branches, poor testing strategies, or complex build schemes) can negatively impact CR, causing delays, reviewer overload, and undetected issues; (iv) CI adds value to CR by anticipating problems, reducing manual tasks, and supporting the distribution of updates; and (v) the joint use of CI and CR presents challenges, such as ensuring code quality, resolving merge conflicts, and aligning processes. These findings shed light on the interplay between CI and CR and offer insights to improve their combined use in closed-source software development.},
}

@article{matos2025data,
  title={Data Privacy in Software Practice: Brazilian Developers’ Perspectives},
  author={Matos, Aryely and Patrício, Mario and Nicolau, Maria Isabel and Canedo, Edna Dias and Pereira, Juliana Alves and Uchôa, Anderson},
  journal={Journal of Internet Services and Applications},
  abstract={Data privacy is an essential principle of information security, aimed at protecting sensitive data from unauthorized access and information leaks. As software systems advance, the volume of personal information also grows exponentially. Therefore, incorporating privacy engineering practices during development is vital to ensure data integrity, confidentiality, and compliance with legal regulations, such as the General Data Protection Regulation (GDPR). However, there is a gap in understanding developers’ awareness of data privacy, their perceptions of the implementation of privacy strategies, and the influence of organizational factors on this adoption. Thus, this paper aims to explore the level of awareness among Brazilian developers regarding data privacy and their perceptions of the implementation strategies adopted to ensure data privacy. Additionally, we seek to understand how organizational factors influence the adoption of data privacy practices. To this end, we surveyed 88 Brazilian developers with privacy-related work experience. We got 21 statements grouped into three topics to measure the Brazilian developers’ awareness of data privacy in software. Our statistical analysis reveals substantial gaps between groups, e.g., developers have Direct v.s. Indirect data privacy-related work experience. We also reveal some data privacy strategies, e.g., Encryption, are both widely used and perceived as highly important, others, such as Turning off data collection, highlight strategies where ease of use does not necessarily lead to widespread adoption. Finally, we identified that the absence of dedicated privacy teams correlates with a lower perceived priority and less investment in tools. Even in organizations that recognize the importance of privacy. Our findings offer insights into how Brazilian developers perceive and implement data privacy practices, emphasizing the critical role organizational culture plays in decision-making regarding privacy. We hope that our findings will contribute to improving privacy practices within the software development community, particularly in contexts similar to Brazil.},
  number={1},
  year={2025},
  month={Jun.},
  volume={16},
  url={https://journals-sol.sbc.org.br/index.php/jisa/article/view/5302},
  DOI={10.5753/jisa.2025.5302},
  pages={299–319}
}

@inproceedings{ferreira2025assessing,
  title={Assessing the Bug-Proneness of Refactored Code: A Longitudinal Multi-Project Study},
  author={Isabella Ferreira and Lawrence Arkoh and Anderson Uchôa and Ana Carla Bibiano and Alessandro Garcia and Wesley K. G. Assunção},
  booktitle={Proceedings of the 29th International Conference on Evaluation and Assessment in Software Engineering (EASE), 2025, Istanbul,Turkey,17-20 June 2025},
  pages={1--12},
  year={2025},
  abstract={Refactoring is a common practice in software development, aimed at improving the internal code structure in order to make it easier to understand and modify. Consequently, it is often assumed that refactoring makes the code less prone to bugs. However, in practice, refactoring is a complex task and applied in different ways (e.g., various refactoring types, single vs. composite refactorings) and with a variety of purposes (e.g., root-canal vs. floss refactoring). Therefore, certain refactorings can inadvertently make the code more prone to bugs. Unfortunately, there is limited research in the literature on the long-term relationship between the different characteristics of refactorings and bugs. This paper presents a longitudinal study of 12 open source software projects, where 27,450 refactorings, 1,033 reported bugs, and 6,219 bugs detected with static analysis tools were analyzed. While our study confirms the common intuition that refactored code is less bug-prone than non-refactored code, we also extend or contradict existing body of knowledge in other ways. First, a code element that undergoes multiple refactorings is not less bug-prone than an element that undergoes a single refactoring. A single refactoring is the one not performed in conjunction with other refactorings in the same commit. Second, single refactorings often induce the occurrence of bugs across all analyzed projects. Third, code elements affected by refactorings made in conjunction with other non-refactoring changes in the same commit (i.e., floss refactorings) are often bug-prone. Finally, many of such bugs induced by refactoring  cannot be revealed with state-of-the-art techniques for detecting behavior-preserving refactorings.},
}

@inproceedings{soares2025relating,
  title={Relating Complexity, Explicitness, Effectiveness of Refactorings and Non-Functional Requirements: A Replication Study},
  author={Vinícius Soares and Lawrence Arkoh and Paulo Roberto Farah and Anderson Uchôa and Alessandro Garcia and Wesley K. G. Assunção},
  booktitle={Proceedings of the 29th International Conference on Evaluation and Assessment in Software Engineering (EASE), 2025, Istanbul,Turkey,17-20 June 2025},
  pages={1--12},
  year={2025},
  abstract={Refactoring is a practice widely adopted during software maintenance and evolution. Due to its importance, there is extensive work on the effectiveness of refactoring in achieving code quality. However, developer's intentions are usually overlooked. A more recent area of study involves the concept of self-affirmed refactoring (SAR), where developers explicitly state their intent to refactor. While studies on SAR have made valuable contributions, they provide little insights into refactoring complexity and effectiveness, as well as the refactorings' relations to specific non-functional requirements. A study by Soares et al. published in 2020 addressed such aspects, but it relied on a quite small sample of studied subject systems and refactoring instances (in addition to other limitations). Following the empirical method of replication, we expanded the scope of Soares et al.'s study by doubling the number of projects analyzed (eight in total), and a significantly larger set of validated refactorings (8,408). Our findings only partially align with the original study. We observed that when developers explicitly state their refactoring intent, the resulting changes typically involve a combination of different refactoring types, making them more complex. Additionally, we confirmed that such complex refactorings positively impact code's internal quality attributes.  Yet, while refactorings targeting non-functional requirements generally enhance code quality compared to refactorings without this explicit concern, our observations only partially confirm the original study’s conclusions. Furthermore, our results contradict the original study in various aspects. For example, we interestingly found that SARs (compared to non-SARs) tend to produce fewer negative effects on internal quality attributes despite their quite frequent complexity. These findings highlight the need for reducing the complexity of refactorings while maximizing their positive effects. They also underscore the importance of explicitly stating refactoring intentions, as this provides a clear mental framework that guides effective refactoring efforts.},
}

@inproceedings{mesquita2025hello,
  title={Hello, Freire! How Can You Help Me? A Smart Chatbot to Enhance Access to Academic Opportunities and Institutional Matters},
  author={Arthur Willame Mesquita and Carlos Freire and Antônio Gomes and Bruna Amazonas and Anderson Uchôa},
  booktitle={Proceedings of the 21st Brazilian Symposium on Information Systems (SBSI), 2025, Recife, Pernambuco, Brazil, 19-23 May 2025},
  pages={1--10},
  year={2025},
  abstract={Context: Universities offer various resources and services that students often fail to utilize due to difficulties in accessing relevant information. Chatbots can improve access and interaction between students and institutions. Problem: Students struggle to find information about academic opportunities and institutional matters due to fragmented data, limiting engagement. Solution: This paper introduces Freire Assistant (Freire), a chatbot system powered by a Large Language Model (LLM) and built using Retrieval Augmented Generation (RAG) pipelines. Freire aims to streamline access to academic information through a fast, intuitive communication channel. IS theory: This work was developed under the aegis of Soft Systems Theory, as it addresses the complexity of accessing academic information as a sociotechnical problem. Method: To evaluate Freire’s effectiveness in providing accurate and relevant information about academic opportunities and institutional matters, we conducted a case study at a Brazilian university. We quantitatively evaluated the contextual quality of Freire's responses using the DeepEval framework. Additionally, we qualitatively evaluated Freire's usability with 45 students through the Chatbot Usability Questionnaire (CUQ) which measures aspects related to Chatbot Personality, Onboarding, User Experience, and Error Handling. Summary of Results: The findings demonstrated Freire’s efficiency in generating contextually relevant and accurate responses. Furthermore, usability scores were generally high due to their simple interface and conversation-driven functionality. Contributions and Impact in the IS area: This study highlights how smart chatbots can enhance user experience and access to information in universities, providing a replicable model for other institutions facing similar challenges.},
}

@inproceedings{pereira2025overcoming,
  title={Overcoming Obstacles: Challenges of Gender Inequality in Undergraduate ICT Programs},
  author={Angelica Pereira Souza and Anderson Uchôa and Edna Dias Canedo and Juliana Alves Pereira and Claudia Pinto Pereira and Larissa Rocha},
  booktitle={Proceedings of the 6th ACM/IEEE Workshop on Gender Equality, Diversity, and Inclusion in Software Engineering (GE), 2025, Ottawa, Ontario, Canada, 27-29 April 2025},
  pages={1--9},
  year={2025},
  abstract={Context: Gender inequality is a widely discussed issue across various sectors, including Information Technology and Communication (ICT). In Brazil, women represent less than 18\% of ICT students in higher education. Prior studies highlight gender-related barriers that discourage women from staying in ICT. However, they provide limited insights into their perceptions as undergraduate students and the factors influencing their participation and confidence. Goal: This study explores the perceptions of women undergraduate students in ICT regarding gender inequality. Method: A survey of 402 women from 18 Brazilian states enrolled in ICT courses was conducted using a mixed-method approach, combining quantitative and qualitative analyses. Results: Women students reported experiencing discriminatory practices from peers and professors, both inside and outside the classroom. Gender stereotypes were found to undermine their self-confidence and self-esteem, occasionally leading to course discontinuation. Conclusions: Factors such as lack of representation, inappropriate jokes, isolation, mistrust, and difficulty being heard contribute to harmful outcomes, including reduced participation and reluctance to take leadership roles. Addressing these issues is essential to creating a safe and respectful learning environment for all students.},
  url = {https://anderson-uchoa.github.io/publications/souza2025overcoming.pdf},
}

@article{uchoa2024towards,
  title={Towards Effective Gamification of Existing Systems: Method and Experience Report},
  journal={Software Quality Journal},
  pages={1:34},
  year={2024},
  author={Anderson Uchôa and Rafael de Mello and Jairo Souza and Leopoldo Teixeira and Baldoino Fonseca and Alessandro Garcia},
  abstract={Context: Gamification promotes user engagement with software features through the incorporation of game elements and rules. Gamification is often incorporated a posteriori into already existing systems. Success in gamifying an existing system depends on careful planning and the evolution of its previously produced software artifacts. This is particularly true for artifacts produced in the earliest development phases, such as the requirements specification. Objective: Incorporating game
elements and rules into an existing system is far from trivial. Developers eventually struggle with performing certain development activities, such as evolving existing requirements and selecting game elements and game rules. This paper reports our practical experience in gamifying an existing system. Based on this experience, we introduce Gamify4Fun, a method that aims to assist developers in performing some key activities to gamify existing systems. Method: We built Gamify4Fun based on the experience of 15 developers involved with the gamification of an existing healthcare system. We started by adopting an original method aimed at gamifying systems being built from scratch. As we needed to adapt the original method for supporting the particularities of gamifying a previously developed system, we refined the original method's development activities and their respective phases. We also interviewed the developers to capture their perception of challenging development activities through gamification. The interviews' outcomes guided some further refinements to the original method. Results: Gamify4Fun supports the gamification of existing systems at the earliest development phases: from the preparation of the system gamification to both the gamification and system design. We refined the development activities of the original method as much as needed; we also used or adapted the activities prescribed by other methods from the literature, in the context of gamification from scratch, to fill gaps whenever necessary. Conclusion: By reporting our practical experience and introducing a gamification method, we expect to guide development teams in gamifying their existing systems, as well as shed insights about the current, unaddressed limitations of existing approaches (including ours) to gamifying existing systems.},
  doi={10.1007/s11219-024-09696-y},
  issn = {1573-1367},
}

@inproceedings{bibano2024enhancing,
  title={Enhancing Recommendations of Composite Refactorings based on the Practice},
  author={Ana Carla Bibiano and Daniel Coutinho and Anderson Uchôa and Wesley K. G. Assunção and Alessandro Garcia and Rafael de Mello and Thelma Colanzi and Daniel Tenório and Audrey Vasconcelos and Baldoino Fonseca dos Santos Neto and Márcio Ribeiro},
  booktitle={Proceedings of the 24th IEEE International Conference on Source Code Analysis and Manipulation (SCAM), 2024, Flagstaff, AZ, United States, 7-8 October 2024},
  pages={1--11},
  year={2024},
  abstract={Refactoring is a non-trivial maintenance activity. Developers spend time and effort refactoring code to remove structural problems, i.e., code smells. Recent studies indicated that developers often apply composite refactoring (composite, for short), i.e., two or more interrelated refactorings. However, prior studies revealed that only 10% of composite refactorings are considered complete, i.e., those fully removing code smells. Many incomplete refactorings can even introduce or replace smells, requiring further removal later in the project. Moreover, existing recommendations are not well-detailed and do not alert developers about possible side effects of current recommendations. To address these gaps, we conducted a large-scale study involving more than 250k refactorings from 42 software projects, including both open-source and closed-source projects. Our goal is to investigate how the most common complete composites are combined and their side effects in the practice. Our results reveal that the current recommendation to apply Extract Method(s) with fine-grained refactoring types needs refinements. We found that certain fine-grained refactorings like Change Variable Types and Change Return Types can introduce up to 45% of Brain Methods when combined with Extract Method(s). Moreover, Extract Method(s) and Move Method(s), a common recommendation to remove Feature Envy, may inadvertently introduce about 30% of Lazy Classes and approximately 70% of Data Classes. Despite these potential side effects, existing refactoring catalogs and tools' recommenders do not alert developers about these side effects. Finally, we consolidate our findings into a catalog to provide clear guidance for developers and researchers on effectively applying composite refactorings to fully remove code smells.},
  url = {https://anderson-uchoa.github.io/publications/bibiano2024enhancing.pdf},
}


@article{darwin2024trivial,
  title={On the Effectiveness of Trivial Refactorings in Predicting Non-trivial Refactorings},
  journal={Journal of Software Engineering Research and Development},
  volume={12},
  pages={5:1 – 5:16},
  year={2024},
  month={Apr.},
  issn = {2195-1721},
  doi={10.5753/jserd.2024.3324},
  author={Darwin Pinheiro and Carla Bezerra and Anderson Uchôa},
  abstract={Refactoring is the process of restructuring source code without changing the external behavior of the software. Refactoring can bring many benefits, such as removing code with poor structural quality, avoiding or reducing technical debt, and improving maintainability, reuse, or code readability. Although there is research on how to predict refactorings, there is still a clear lack of studies that assess the impact of operations considered less complex (trivial) to more complex (non-trivial). In addition, the literature suggests conducting studies that invest in improving automated solutions through detecting and correcting refactoring. This study aims to identify refactoring activity in non-trivial operations through trivial operations accurately. For this, we use classifier models of supervised learning, considering the influence of trivial refactorings and evaluating performance in other data domains. To achieve this goal, we assembled 3 datasets totaling 1,291 open-source projects, extracted approximately 1.9M refactoring operations, collected 45 attributes and code metrics from each file involved in the refactoring and used the algorithms Decision Tree, Random Forest, Logistic Regression, Naive Bayes and Neural Network of supervised learning to investigate the impact of trivial refactorings on the prediction of non-trivial refactorings. For this study, we contextualize the data and call context each experiment configuration in which it combines trivial and non-trivial refactorings. Our results indicate that: (i) Tree-based models such as Random Forest, Decision Tree, and Neural Networks performed very well when trained with code metrics to detect refactoring opportunities. However, only the first two were able to demonstrate good generalization in other data domain contexts of refactoring; (ii) Separating trivial and non-trivial refactorings into different classes resulted in a more efficient model. This approach still resulted in a more efficient model even when tested on different datasets; (iii) Using balancing techniques that increase or decrease samples may not be the best strategy to improve models trained on datasets composed of code metrics and configured according to our study.},
  url={https://anderson-uchoa.github.io/publications/darwin2024trivial.pdf},

}

@inproceedings{ivens2023factors,
  title={What Factors Affect the Build Failures Correction Time? A Multi-Project Study},
  author={Gustavo Ivens and Carla Bezerra and Anderson Uchôa and Ivan Machado},
  booktitle={Proceedings of the 17th Brazilian Symposium on Software Components, Architectures, and Reuse (SBCARS), 2023, Campo Grande, MS, Brazil, 25-27 September 2023},
  pages={1--10},
  year={2023},
  abstract={Continuous Integration (CI) is a widely adopted practice in modern software engineering that involves integrating developers' local changes with the project baseline daily. Despite its popularity, recent studies have revealed that integrating changes can be time-consuming, requiring significant effort to correct errors that arise. This can lead to development activities being paused, including the addition of new features and fixing bugs, while developers focus on analyzing and correcting build failures. In this study, we investigate the factors that influence the time taken to correct build failures in CI. Specifically, we analyze the impact of developer activity, project characteristics, and build complexity on build failure correction time. To conduct our analysis, we collected data from 18 industrial projects of a software company, calculating 13 metrics for each project based on the literature on build failures analysis. We used association rules, a data mining technique, to examine the relationship between the defined factors and build failure correction time. Our findings reveal significant correlations between the factors studied and the duration of build failure correction time. Specifically, we found that more experienced developers require less time to correct build failures, while build failures that originate in the early stages of the project are resolved more quickly. Additionally, we observed that build failures with more lines and modified files tend to have longer correction times. Overall, this study sheds light on the factors that impact build failure correction time in CI. By identifying these factors, our findings can help software development teams optimize their CI processes and minimize the impact of build failures on development activities.},
  url = {https://anderson-uchoa.github.io/publications/ivens2023factors.pdf},

}

@inproceedings{marcos2023ciref,
  title={CIRef: A Tool for Visualizing the Historical Data of Software Refactorings in Java Projects},
  author={Marcos Silva and Maykon Nunes and Carla Bezerra and Anderson Uchôa and Mairieli Wessel},
  booktitle={Proceedings of the 37th Brazilian Symposium on Software Engineering (SBES), Tools Track, 2023, Campo Grande, MS, Brazil, 27-29 September 2023},
  pages={1--6},
  year={2023},
  abstract={Context: Refactorings are actions developers do not often do in a standard way. One of the reasons is the lack of visualizations in current tools capable of identifying refactorings. Code visualizations can help developers make decisions about analyzing code quality and possible code refactorings. Objective: We present CIRef, a tool for visualizing the historical data of refactorings in Java projects. For a particular project, CIRef provides a wide range of visualizations including customizable rankings of the importance of different refactoring types, duels between developers to understand their profiles, and a timeline of the number of refactorings performed. Method: To validate the acceptance and perceived usefulness of CIRef, we conducted a study with eight developers using the Technology Acceptance Model (TAM). Results: The results indicate that 75% of the participants agreed with using the tool in the future and found it easy to use. Conclusions: Despite supporting developers in visualizing historical refactoring data, CIRef also has the potential for educational purposes. It can help teachers visualize the history of refactorings performed by students, especially in educational environments focused on programming and maintaining Java projects. Video link: https://figshare.com/s/99c9e2ca3fb227b649a1.},
  url = {https://anderson-uchoa.github.io/publications/marcos2023ciref.pdf},

}

@inproceedings{barbosa2023beyond,
  title={Beyond the Code: Investigating the Effects of Pull Request Conversations on Design Decay},
  author={Caio Barbosa and Anderson Uchôa and Daniel Coutinho and Wesley K. G. Assunção and Anderson Oliveira and Alessandro Garcia and Baldoino Fonseca and Matheus Feitosa de Oliveira Rabelo and José Eric Mesquita Coelho and Eryka Carvalho da Silva and Paulo Henrique Santos Marques},
  booktitle={Proceedings of the 17th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM), 2023, New Orleans, USA, 23-27 October 2023},
  pages={1--12},
  year={2023},
  abstract={Background: Code development is done collaboratively and supported by platforms, such as GitHub and GitLab. These platforms contribute to collaborative software development, offering a pull-based development model. In this model, developers actively communicate and share their knowledge through conversations. However, pull request conversations are affected by several social aspects, such as communication dynamics among developers, discussion content, and organizational dynamics, which may directly impact the quality of the software. Despite prior studies indicating that social aspects indeed impact software quality, it is still unknown to what extent social aspects influence design decay during software development. Thus, since social aspects are intertwined with design and implementation decisions, there is a need for investigating how social aspects contribute to avoiding, reducing, or accelerating design decay. Aims: To fill this gap, we performed a study aimed at investigating the effects of pull request conversation on design decay. Method: We investigated 10,746 pull request conversations from 11 open-source systems. The pull request conversations were characterized in terms of three different social aspects: discussion content, organizational and communication dynamics. We observed and characterized 18 social metrics to these three social aspects, and analyzed how they associate with design decay. To this end, we used a statistical approach to assess which social metrics are able to discriminate between impactful and unimpactful pull requests. Then, we employed a multiple logistic regression model to evaluate the influence of each social metric per social aspect in the presence of each other on design decay. Finally, we also observed how the combination of all social metrics influences the design decay. Results: Our findings reveal that social metrics related to the size and duration of a discussion, the presence of design-related keywords, the team size, and gender diversity can be used to discriminate between design impactful and unimpactful pull requests. Second, organizational growth and gender diversity prevent decay. Third, each software community has its unique set of social aspects that can be used to detect and prevent design decay. Finally, design improvements can be accomplished by timely feedback, engaged communication, and design-oriented discussions with the contribution of multiple participants who provide significant comments. Conclusion: The social aspects related to pull request conversations are useful indicators of design decay.},
  url = {https://anderson-uchoa.github.io/publications/barbosa2023beyond.pdf},

}

@inproceedings{oliveira2023dont,
  title={Don't Forget the Exception! Considering Robustness Changes to Identify Design Problems},
  author={Anderson Oliveira and João Lucas Correia and Leonardo Sousa and Wesley K. G. Assunção and Daniel Coutinho and Alessandro Garcia and Willian Oizumi and Caio Barbosa and Anderson Uchôa and Juliana Alves Pereira},
  booktitle={Proceedings of the 20th International Conference on Mining Software Repositories (MSR), 2023, Melbourne, Australia, 15-16 May 2023},
  pages={1--12},
  year={2023},
  doi = {10.1109/MSR59073.2023.00064},
  abstract={Modern programming languages, such as Java, use exception-handling mechanisms to guarantee the robustness of software systems. Although important, the quality of exception code is usually poor and neglected by developers. Indiscriminate robustness changes (e.g., the addition of empty catch blocks) can indicate design decisions that negatively impact the internal quality of software systems. As it is known in the literature, multiple occurrences of poor code structures, namely code smells, are strong indicators of design problems. Still, existing studies focus mainly on the correlation of maintainability smells with design problems. However, using only these smells may not be enough since developers need more context (e.g., system domain) to identify the problems in certain scenarios. Moreover, these studies do not explore how changes in the exceptional code of the methods combined with maintainability smells can give complementary evidence of design problems. By covering both regular and exception codes, the developer can have more context about the system and find complementary code smells that reinforce the presence of design problems. This work aims to leverage the identification of design problems by tracking poor robustness changes combined with maintainability smells. We investigated the correlation between robustness changes and maintainability smells on the commit history of more than 160k methods from different releases of 10 open-source software systems. We observed that maintainability smells can be worsened or even introduced when robustness changes are performed. This scenario mainly happened for the smells Feature Envy, Long Method, and Dispersed Coupling. We also analyzed the co-occurrence between robustness and maintainability smells. We identified that the empty catch block and catch throwable robustness smells were the ones that co-occurred the most with maintainability smells related to the Concern Overload and Misplaced Concern design problems. The contribution of our work is to reveal that poor exception code, usually neglected by developers, negatively impacts the quality of methods and classes, signaled by the maintainability smells. Therefore, existing code smell detecting tools can be enhanced to leverage robustness changes to identify design problems.},
  url = {https://anderson-uchoa.github.io/publications/oliveira2023dont.pdf},
 }

@article{BIBIANO2023107134,
  title = {Composite refactoring: Representations, characteristics and effects on software projects},
  journal = {Information and Software Technology},
  volume = {156},
  pages = {107134},
  year = {2023},
  issn = {0950-5849},
  doi = {https://doi.org/10.1016/j.infsof.2022.107134},
  url = {https://www.sciencedirect.com/science/article/pii/S0950584922002439},
  author = {Ana Carla Bibiano and Anderson Uchôa and Wesley K.G. Assunção and Daniel Tenório and Thelma E. Colanzi and Silvia Regina Vergilio and Alessandro Garcia},
  keywords = {Code refactoring, Composite refactoring, Software maintenance, Software project, Systematic mapping},
  abstract = {Context: code refactoring is a code transformation that aims to improve software quality. A composite refactoring (or, simply, composite) is defined by two or more interrelated refactorings, which is often applied by developers. Each composite needs to be somehow represented and has its own characteristics (e.g., code scope) as well as its effects on software quality. However, these basic elements of composites are rarely studied systematically. The lack of systematic knowledge also misguides the design of automated support tools for supporting composite refactoring. Thus, researchers might have controversial views about basic elements of composite refactorings. An example of these literature conflicts concerns the effect of composites: while some studies suggest composites more often remove code smells, other studies indicate composites often introduce code smells. Objective: in this sense, our study aims at analyzing the technical literature of composite refactoring and building a conceptual framework of the representation models, characteristics, and the effect of composite refactoring. Method: we conducted a systematic mapping with 140 primary empirical studies about refactoring. Our systematic mapping summarizes the current knowledge on composites and also presents a conceptual framework intended to characterize composite refactoring. Results: our conceptual framework presents seven representation models, nine characteristics, and thirteen effects of composites. We found out that studies used multidimensional representations, like graphs, to determine what refactoring(s) may be suggested and combined. On composite characteristics, studies mentioned developers often finish a composite in up to a month. However, these studies do not detail why and when composites span for several weeks. Then, we discussed other existing gaps on the current literature of composites. For instance, while most of the studies report the effect of composites on internal software quality, e.g., code smells, their effect on external software quality is little explored. Conclusion: our results can motivate future studies to more deeply investigate composite refactoring applications, and the improvement of tooling support for composite refactorings.}
}
@article{ALMEIDA2023107142,
  title = {Negative effects of gamification in education software: Systematic mapping and practitioner perceptions},
  journal = {Information and Software Technology},
  volume = {156},
  pages = {107142},
  year = {2023},
  issn = {0950-5849},
  doi = {https://doi.org/10.1016/j.infsof.2022.107142},
  url = {https://www.sciencedirect.com/science/article/pii/S0950584922002518},
  author = {Cláuvin Almeida and Marcos Kalinowski and Anderson Uchôa and Bruno Feijó},
  keywords = {Gamification, Negative effects, Education, Learning, Systematic mapping, Snowballing, Focus group},
  abstract = {Context: While most research shows positive effects of gamification, the focus on its adverse effects is considerably smaller and further understanding of these effects is needed. Objective: To provide a comprehensive overview on research reporting negative effects of game design elements and to provide insights into the awareness of developers on these effects and into how they could be considered in practice. Method: We conducted a systematic mapping study of the negative effects of game design elements on education/learning systems. We also held a focus group discussion with developers of a gamified software, discussing the mapping study results with regard to their awareness and perceptions on the reported negative effects in practice. Results: The mapping study revealed 87 papers reporting undesired effects of game design elements. We found that badges, leaderboards, competitions, and points are the game design elements most often reported as causing negative effects. The most cited negative effects were lack of effect, worsened performance, motivational issues, lack of understanding, and irrelevance. The ethical issues of gaming the system and cheating were also often reported. As part of our results, we map the relations between game design elements and the negative effects that they may cause. The focus group revealed that developers were not aware of many of the possible negative effects and that they consider this type of information useful. The discussion revealed their agreement on some of those potential negative effects and also some positive counterparts. Conclusions: Gamification, when properly applied, can have positive effects on education/learning software. However, gamified software is also prone to generate harmful effects. Revealing and discussing potentially negative effects can help to make more informed decisions considering their trade-off with respect to the expected benefits.}
}

@article{9904005,
  author = {R. de Mello and R. Oliveira and A. Uchôa and W. Oizumi and A. Garcia and B. Fonseca and F. de Mello},
  journal = {IEEE Software},
  title = {Recommendations for Developers Identifying Code Smells},
  year = {2023},
  volume = {40},
  number = {02},
  issn = {1937-4194},
  pages = {90-98},
  abstract = {Identifying code smells is a widely disseminated practice for preventing software systems from design problems and other maintainability issues. This task remains challenging and manual despite several catalogues and detection tools being available. The complexity involved in identifying a code smell requires the developer’s ability to analyse its surrounding context, reflecting on its actual incidence and need for removal. Despite the predominantly manual nature of the task, there is still quite limited knowledge of the human and social aspects involved. In this sense, we conducted several investigations centred on the community of software developers in recent years. The outcomes of this work provide a comprehensive view of the task and emerging findings, such as the developers’ major beliefs, values, and ideas about identifying code smells. Based on these outcomes, we present practical recommendations to developers to optimise efforts in identifying code smells.},
  keywords = {codes;software;task analysis;software systems;frequency measurement;psychology;complexity theory},
  doi = {10.1109/MS.2022.3203716},
  url = {https://ieeexplore.ieee.org/document/9904005},
  publisher = {IEEE Computer Society},
  address = {Los Alamitos, CA, USA},
  month = {mar}
}

@inproceedings{pinheiro2022how,
  title={How do Trivial Refactorings Affect Classification Prediction Models?},
  author={Darwin Pinheiro and Carla Bezerra and Anderson Uchôa},
  booktitle={Proceedings of the 16th Brazilian Symposium on Software Components, Architectures, and Reuse (SBCARS), 2022, Uberlandia, Brazil, October 3--4},
  pages = {81–90},
  isbn = {9781450397452},
  note={<font color="red"> Best Paper Award </font>},
  year={2022},
  abstract={Refactoring is defined as a transformation that changes the internal structure of the source code without changing the external behavior. Keeping the external behavior means that after applying the refactoring activity, the software must produce the same output as before the activity. The refactoring activity can bring several benefits, such as: removing code with low structural quality, avoiding or reducing technical debt, improving code maintainability, reuse or readability. In this way, the benefits extend to internal and external quality attributes. The literature on software refactoring suggests carrying out studies that invest in improving automated solutions for detecting and correcting refactoring. Furthermore, few studies investigate the influence that a less complex type of refactoring can have on predicting more complex refactorings. This paper investigates how less complex (trivial) refactorings affect the prediction of more complex (non-trivial) refactorings. To do this, we classify refactorings based on their triviality, extract metrics from the code, contextualize the data and train machine learning algorithms to investigate the effect caused. Our results suggest that: (i) machine learning with tree-based models (Random Forest and Decision Tree) performed very well when trained with code metrics to detect refactorings; (ii) separating trivial from non-trivial refactorings into different classes resulted in a more efficient model, indicative of improving the accuracy of automated solutions based on machine learning; and, (iii) using balancing techniques that increase or decrease samples randomly is not the best strategy to improve datasets composed of code metrics.},
  doi = {10.1145/3559712.3559720},
  url={https://anderson-uchoa.github.io/publications/pinheiro2022how.pdf}
}

@inproceedings{souza2022tel,
  title={TEl-IoT: A Template for Eliciting IoT Software System Requirements},
  author={Sabrina R. de Souza and Bruno P. de Souza and Anderson Uchôa and Daniella de O. Costa},
  booktitle={Proceedings of the XVIII Brazilian Symposium on Information Systems (SBSI), 2022, Curitiba, Brazil, May 16--19},
  pages={1--8},
  year={2022},
  isbn = {9781450396981},
  abstract={Context: The Internet of Things (IoT) is a network of physical objects and system connected through mutual communication protocols. IoT systems have specific characteristics such as, self-configuration, dynamic changes, device and software heterogeneity. Goal: As IoT systems incorporate several components of the software, hardware, communication, and other features, building requirements documents to such systems become a challenge for Requirements Engineering (RE). Thus, this paper presents TEl-IoT, a template to aid developers during the requirements elicitation activities for IoT systems. Method: We conducted three evidence-based studies. We first performed a literature review aiming to identify artifacts that support requirements elicitation and specification for IoT systems. Second, based on the literature review, we proposed the initial version of the TEl-IoT. Finally, we performed two empirical studies to assess the TEl-IoT: (i) feasibility study with industry regarding the first version of TEl-IoT, and (ii) an observational study to understand how students apply the TEl-IoT in an IoT project. Results: Our results showed that TEl-IoT is viable, and its use reduces the time spent on requirements elicitation, in comparison with the ad-hoc way. In addition, our qualitative results also suggested that the use of TEl-IoT facilitates the requirements elicitation for IoT systems. Conclusion: We expect our template to guide requirements elicitation for IoT systems in practice. Our results showed that TEl-IoT can support developers and contribute to the body of knowledge about RE applicable in the IoT context.},
  url={https://anderson-uchoa.github.io/publications/souza2022tel.pdf},
  doi = {10.1145/3535511.3535538}
}

@inproceedings{coutinho2022on,
  title={On the Influential Interactive Factors on Degrees of Design Decay: A Multi-Project Study},
  author={Daniel Coutinho and Anderson Uchôa and Caio Barbosa and Vinícius Soares and Alessandro Garcia and Marcelo Schots and Juliana Alves Pereira and Wesley K. G. Assunção},
  booktitle={Proceedings of the 29th IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER), 2022, Honolulu, Hawaii, March 15--18},
  pages={1--12},
  year={2022},
  abstract={Developers constantly perform code changes throughout the lifetime of a project. These changes may induce the introduction of design problems (design decay) over time, which may be reduced or accelerated by interacting with different factors (e.g., refactorings) that underlie each change. However, existing studies lack evidence about how these factors interact and influence design decay. Thus, this paper reports a study aimed at investigating whether and how (associations of) process and developer factors influence design decay. We studied seven software systems, containing an average of 45K commits in more than six years of project history. Design decay was characterized in terms of five internal quality attributes: cohesion, coupling, complexity, inheritance, and size. We observed and characterized 12 (sub-)factors and how they associate with design decay. To this end, we employed association rule mining. Moreover, we also differentiate between the associations found on modules with varying levels of decay. Process-and developer-related factors played a key role in discriminating these different levels of design decay. Then, we focused on analyzing the effects of potentially interacting factors regarding slightly-and largely-decayed modules. Finally, we observed diverging decay patterns in these modules. For example, individually, the developer-related sub-factor that represented first-time contributors, as well as the process-related one that represented the size of a change did not have negative effects on the changed classes. However, when analyzing specific factor interactions, we saw that changes in which both of these factors interacted tended to have a negative effect on the code, leading to decay.},
  url={https://anderson-uchoa.github.io/publications/coutinho2022on.pdf},
  doi = {10.1109/SANER53432.2022.00093}
}

@inproceedings{uchoa2021do,
  title={Do Critical Components Smell Bad? An Empirical Study with Component-based Software Product Lines},
  author={Anderson Uchôa and Wesley K.G. Assunção and Alessandro Garcia},
  booktitle={Proceedings of the 15th Brazilian Symposium on Software Components, Architectures, and Reuse (SBCARS), 2021, Joinville, Brazil, September 27 to October 1},
  pages={1--10},
  note={<font color="red"> Distinguished Paper Award -- 2nd Place </font>},
  year={2021},
  abstract={Component-based software product line (SPL) consists of a set of software products that share common components. For a proper SPL product composition, each component has to follow three principles: encapsulating a single feature, restricting data access, and be replaceable. However, it is known that developers usually introduce anomalous structures, i.e., code smells, along the implementation of components. These code smells might violate one or more component principles and hinder the SPL product composition. Thus, developers should identify code smells in component-based SPLs, especially those affecting highly interconnected components, which are called critical components. Nevertheless, there is limited evidence of how smelly these critical components tend to be in component-based SPLs. To address this limitation, this paper presents a survey with developers of three SPLs. We inquire these developers about their perceptions of a critical component. Then, we characterize critical components per SPL, and identify nine recurring types of code smells. Finally, we quantitatively assess the smelliness of the critical components. Our results suggest that: (i) critical components are ten times more prone to have code smells than non-critical ones; (ii) the most frequent code smell types affecting critical components violate several component principles together; and (iii) these smell types affect multiple SPL components.},
  url={https://anderson-uchoa.github.io/publications/uchoa2021do.pdf},
  doi = {10.1145/3483899.3483907}
}

@inproceedings{martins2021how,
  title={How do Code Smell Co-occurrences Removal Impact Internal Quality Attributes? A Developers' Perspective},
  author={Júlio Martins and Carla Bezerra and Anderson Uchôa and Alessandro Garcia},
  booktitle={Proceedings of the 35th Brazilian Symposium on Software Engineering (SBES), 2021, Joinville, Brazil, September 27 to October 1},
  pages={1--10},
  year={2021},
  abstract={Code smells are poor code structures that might harm the software quality and evolution. However, previous studies has shown that only individual occurrences of smells may not be enough to assess the real impact that these smells can bring on systems. In this context, the co-occurrences of code smells, i.e., occurrences of more than one code smell in the same class or same method, can be better indicators of design problems for software quality. Despite its importance as an indicator of design problems, we have little known about the impact of removing the co-occurrence of smells via software refactoring on internal quality attributes, such as coupling, cohesion, complexity, and inheritance. It is even less clear on what is the developers' perspective on the co-occurrences removal. We aim at addressing this gap through a qualitative study with 14 developers. To this end, we analyze the refactorings employed by developers during the removal of 60 code smells co-occurrences, during 3 months in 5 closed-source projects. We observe (i) impact of code smells co-occurrences on internal quality attributes, (ii) which are the most harmful co-occurrences from the developers’ perspective, (iii) developers' perceptions during the removal of code smells co-occurrence via refactoring activities; and (iv) what are the main difficulties faced by developers during the removal of code smells co-occurrences in practice. Our findings indicate that: (i) the refactoring of some types of code smells co-occurrences (e.g., Dispersed Coupling--God Class) indicated improvement for the quality attributes; (ii) refactoring code smells co-occurrences according to the developers is difficult mainly due to the understanding of the code and complexity refactoring methods; and (iii) developers still have insecurities regarding the identification and refactoring of code smells and their co-occurrences.},
  url={https://anderson-uchoa.github.io/publications/julio2021how.pdf},
  doi = {10.1145/3474624.3474642}
}

@inproceedings{uchoa2021unveiling,
  title={Unveiling Multiple Facets of Design Degradation in Modern Code Review},
  author={Uchôa, Anderson},
  booktitle={Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE 2021), 2021, Athens, Greece, August 23--28},
  pages={1615–1619},
  year={2021},
  abstract={Software design is a key concern in code review through which developers actively discuss and improve each code change. Nevertheless, code review is predominantly a cooperative task influenced by both technical and social aspects. Consequently, these aspects can play a key role in how software design degrades as well as contributing to accelerating or reversing the degradation during the process of each single code change’s review. However, there is little understanding about such social and technical aspects relates to either the reduction or the increase of design degradation as the project evolves. Consequently, the scarce knowledge on this topic helps little in properly guiding developers along design-driven code reviews. Our goal in this Doctoral research is three-fold: (1)to characterize the impact of code review and their practices on design degradation over time; (2) to understand the contribution of technical and social aspects to design degradation; and (3) to propose a conceptual framework to support design-decision making during code review. Our preliminary results show that the majority of code reviews had little to no design degradation impact, and that technical and social aspects contribute to distinguishing and predicting design impactful changes.},
  url={https://anderson-uchoa.github.io/publications/uchoa2021unveiling.pdf},
  doi = {10.1145/3468264.3473099}
}

@inproceedings{UchoaBCOARVAPOG21,
  title={Predicting Design Impactful Changes in Modern Code Review: A Large-Scale Empirical Study},
  author={Uchôa, Anderson and Barbosa, Caio and Coutinho, Daniel and Oizumi, Willian and K. G. Assunção, Wesley and Regina Vergilio, Silvia and Alves Pereira, Juliana and Oliveira, Anderson and Garcia, Alessandro},
  booktitle={Proceedings of the 18th International Conference on Mining Software Repositories (MSR 2021), 2021, Madrid, Spain, May 17--19},
  pages={1 -- 12},
  year={2021},
  abstract={Companies have adopted modern code review as a key technique for continuously monitoring and improving the quality of software changes. One of the main motivations for this is the early detection of design impactful changes, to prevent that design-degrading ones prevail after each code review. Even though design degradation symptoms often lead to changes' rejections, practices of modern code review alone are actually not sufficient to avoid or mitigate design decay. Software design degrades whenever one or more symptoms of poor structural decisions, usually represented by smells, end up being introduced by a change. Design degradation may be related to both technical and social aspects in collaborative code reviews. Unfortunately, there is no study that investigates if code review stakeholders, e.g, reviewers, could benefit from approaches to distinguish and predict design impactful changes with technical and/or social aspects. By analyzing 57,498 reviewed code changes from seven open-source systems, we report an investigation on prediction of design impactful changes in modern code review. We evaluated the use of six ML algorithms to predict design impactful changes. We also extracted and assessed 41 different features based on both social and technical aspects. Our results show that Random Forest and Gradient Boosting are the best algorithms. We also observed that the use of technical features results in more precise predictions. However, the use of social features alone, which are available even before the code review starts (e.g., for team managers or change assigners), also leads to highly-accurate prediction. Therefore social and/or technical prediction models can be used to support further design inspection of suspicious changes early in a code review process. Finally, we provide an enriched dataset that allows researchers to investigate the context behind design impactful changes during the code review process.},
  organization={IEEE Press},
  url={https://anderson-uchoa.github.io/publications/UchoaBCOARVAPOG21.pdf},
  doi = {10.1109/MSR52588.2021.00059}
}

@inproceedings{LimaUCCL20,
  title={Visualizing the Maintainability of Feature Models in SPLs},
  author={Lima, Luan and Uchôa, Anderson and Bezerra, Carla and Coutinho, Emanuel and Rocha, Lincoln},
  booktitle={Proceedings of the 8th Workshop on Software Visualization, Evolution and Maintenance (VEM 2020), 2020, Natal, Brazil, Oct 19},
  pages={1 -- 8},
  year={2020},
  abstract={This paper presents data visualizations obtained from the application of 15 measures used to support the maintainability evaluation of Software Product Line (SPL) and Dynamic SPL (DSPL) Feature Models (FMs). To identify these visualizations, we applied a survey to classify a set of 40 measures for evaluating the (D)SPL FMs maintainability. Five visualizations were designed from this classification to analyze the extensibility, static variability, dynamic variability, and structural complexity of the FMs. As result, the experts concluded the designed visualizations assist in FMs maintainability interpretation.},
  url={https://anderson-uchoa.github.io/publications/LimaUCCL20.pdf},
  doi = {10.5753/vem.2020.14522},
}

@inproceedings{SoaresOFBCGVSOU20,
  title={On the Relation between Complexity, Explicitness, Effectiveness of Refactorings and Non-Functional Concerns},
  author={Soares, Vinícius and Oliveira, Anderson and Farah, Paulo and Bibiano, Ana and Coutinho, Daniel and Garcia, Alessandro and Vergilio, Silvia and Schots, Marcelo and Oliveira, Daniel and Uchôa, Anderson},
  booktitle={Proceedings of the 34th Brazilian Symposium on Software Engineering (SBES), 2020, Natal, Brazil, Oct 19-23},
  pages={788--797},
  year={2020},
  abstract={Developers need to consistently improve the internal structural quality of a program to address its maintainability and possibly other non-functional concerns. Refactoring is the main practice to improve code quality. Typical refactoring factors, such as their complexity and explicitness (i.e., their self-affirmation), may influence its effectiveness in improving key internal code attributes, such as enhancing cohesion or reducing its coupling, complexity and size. However, we still lack an understanding of whether such concerns and factors play a role on improving the code structural quality. Thus, this paper investigates the relationship between complexity, explicitness and effectiveness of refactorings and non-functional concerns in four projects. We study four non-functional concerns, namely maintainability, security, performance, and robustness. Our findings reveal that complex refactorings indeed have an impactful effect on the code structure, either improving or reducing the code structural quality. We also found that both self-affirmed refactorings and non-functional concerns are usually accompanied by complex refactorings, but tend to have a negative effect on code structural quality. Our findings can: (i) help researchers to improve the design of empirical studies and refactoring-related tools, and (ii) warn practitioners on which circumstances their refactorings may cause a negative impact on code quality.},
  organization={ACM Press},
  url={https://anderson-uchoa.github.io/publications/SoaresOFBCGVSOU20.pdf},
  doi = {10.1145/3422392.3422439}
}

@inproceedings{MartinsABA20,
  title={Are Code Smell Co-occurrences Harmful to Internal Quality Attributes? A Mixed-Method Study},
  author={Martins, Júlio and Uchôa, Anderson and Bezerra, Carla and Garcia, Alessandro},
  booktitle={Proceedings of the 34th Brazilian Symposium on Software Engineering (SBES), 2020, Natal, Brazil, Oct 19-23},
  pages={52--61},
  year={2020},
  abstract={Previous studies demonstrated how code smells (i.e., symptoms of the presence of system degradation) impact the software maintainability. However, few studies have investigated which code smell types tend to co-occur in the source code. Moreover, it is not clear to what extent the removal of code smell co-occurrences -- through refactoring operations -- has a positive impact on quality attributes such as cohesion, coupling, inheritance, complexity, and size. We aim at addressing these gaps through an empirical study. By investigating the impact of the smells co-occurrences in 11 releases of 3 closed-source systems, we observe (i) which code smells tend to co-occur together, (ii) the impact of the removal of code smell co-occurrences on quality internal attributes before and after refactoring, and (iii) which are the most difficult co-occurrences to refactoring from the developers perspective. Our results show that 5 types of code smell generally tend to co-occur (e.g, Feature Envy, and Long Method). Moreover, we observed that the removal of code smells co-occurrences lead to a significant reduction in the complexity of the systems studied was obtained. Conversely, cohesion, coupling, and inheritance tend to increase. Based on our findings, we argue that further research is needed on the impact of co-occurrences of code smells on internal quality attributes.},	
  organization={ACM Press},
  url={https://anderson-uchoa.github.io/publications/MartinsABA20.pdf},
  doi = {10.1145/3422392.3422419}
}

@inproceedings{BarbosaAFDHGAFMVL20,
  title={Revealing the Social Aspects of Design Decay: A Retrospective Study of Pull Requests},
  author={Barbosa, Caio and Uchôa, Anderson and Falcao, Filipe and Coutinho, Daniel and Brito, Hyago and Amaral, Guilherme and Garcia, Alessandro, and Fonseca, Baldoino, and Ribeiro, Marcio and Soares, Vinicius and Sousa, Leonardo},
  booktitle={Proceedings of the 34th Brazilian Symposium on Software Engineering (SBES), 2020, Natal, Brazil, Oct 19-23},
  pages={364--373},
  year={2020},
  abstract={The pull-based development model, popularized by social coding environments like GitHub, is widely used by open-source communities. In this model, developers actively communicate and share their knowledge or opinions through the exchange of comments. Their goal is to improve the change under development, including its positive impact on design structure. In this context, two central social aspects may contribute to combating or adversely amplifying design decay. First, design decay may be avoided, reduced or accelerated depending whether the communication dynamics among developers -- who play specific roles -- is fluent and consistent along a change. Second, the discussion content itself may be decisive to either improve or deteriorate the structural design of a system. Unfortunately, it has not been studied so far the role these key social aspects play on avoiding or amplifying design decay. Previous work either investigates technical aspects of design decay or confirms the high frequency of design discussions in pull-based software development. This paper reports a retrospective study aimed at understanding the role of communication dynamics and discussion content on design decay. We focused our analysis on 11 social metrics related to these two aspects as well as 4 control technical metrics typically used as indicators of design decay. We analyzed more than 11k pull request discussions mined from five large open-source software systems. Our findings reveal that many social metrics can be used to discriminate between design impactful and unimpactful pull requests. Second, various factors of communication dynamics are related to design decay. However, temporal factors of communication dynamics outperformed the participant roles' factors as indicators of design decay. Finally, we noticed certain social metrics tend to be indicators of design decay when analyzing both aspects together.},	
  organization={ACM Press},
  url={https://anderson-uchoa.github.io/publications/BarbosaAFDHGAFMVL20.pdf},
  doi = {10.1145/3422392.3422443}
}

@inproceedings{UchoaCWPRAC20,
  title={How Does Modern Code Review Impact Software Design Degradation? An In-depth Empirical Study},
  author={Uchôa, Anderson and Barbosa, Caio and Oizumi, Willian and Blenilio, Publio and Lima, Rafael and Garcia, Alessandro and Bezerra, Carla},
  booktitle={Proceedings of the 36th International Conference on Software Maintenance and Evolution (ICSME), 2020, Adelaide, Australia, Sept 27-Oct 3},
  pages={511--522},
  year={2020},
  abstract={Software design is an important concern in modern code review through which multiple developers actively discuss and improve each single code change. However, there is little understanding of the impact of such developers' reviews on continuously reducing design degradation over time. It is even less clear to what extent and how design degradation is reversed during the process of each single code change's review. In summary, existing studies have not assessed how the process of design degradation evolution is impacted along: (i) within each single review, and (ii) across multiple reviews. As a consequence, one cannot understand how certain code review practices consistently contribute to either reduce or further increase design degradation as the project evolves. We aim at addressing these gaps through a multi-project retrospective study. By investigating 14,971 code reviews from seven software projects, we report the first study that characterizes how the process of design degradation evolves within each review and across multiple reviews. Moreover, we analyze a comprehensive suite of metrics to enable us to observe the influence of certain code review practices on combating or even accelerating design degradation. Our results show that the majority of code reviews had little to no design degradation impact in the analyzed projects. Even worse, this observation also applies, to some extent, to reviews with an explicit concern on design. Surprisingly, the practices of long discussions and high proportion of review disagreement in code reviews were found to increase design degradation. Finally, we also discuss how the study findings shed light on how to improve the research and practice of modern code review.},	
  organization={IEEE Press},
  url={https://anderson-uchoa.github.io/publications/UchoaCWPRAC20.pdf},
  doi = {10.1109/ICSME46990.2020.00055}
}

@mastersthesis{Uchoa19,
  author    = {Anderson Gonçalves Uchôa}, 
  title     = {On Gamifying an Existing Software System: Method, Conceptual Model and Lessons Learned},
  school    = {Pontifical Catholic University of Rio de Janeiro (PUC-Rio)},
  year      = {2019},
  doi = {https://doi.org/10.17771/PUCRio.acad.47298},
  url       = {https://anderson-uchoa.github.io/publications/Uchoa19.pdf}
}

@inproceedings{PaixaoAADAJA20,
  title={Behind the Intents: An In-depth Empirical Study on Software Refactoring in Modern Code Review},
  author={Paixao, Matheus and Uchôa, Anderson and Bibiano, Ana Carla and Oliveira, Daniel and Garcia, Alessandro and Krinke, Jens and Arnovio, Emilio},
  booktitle={Proceedings of the 17th International Conference on Mining Software Repositories (MSR), 2020, Seoul, South Korea, May},
  pages={1 -- 11},
  year={2020},
abstract={Code refactorings are of pivotal importance in modern code review. Developers may preserve, revisit, add or undo refactorings through changes' revisions. Their goal is to certify that the driving intent of a code change is properly achieved. Developers' intents behind refactorings may vary from pure structural improvement to facilitating feature additions and bug fixes. However, there is little understanding of the refactoring practices performed by developers during the code review process. It is also unclear whether the developers’ intents influence the selection, composition, and evolution of refactorings during the review of a code change. Through mining 1,780 reviewed code changes from 6 systems pertaining to two large open-source communities, we report the first in-depth empirical study on software refactoring during code review. We inspected and classified the developers’ intents behind each code change into 7 distinct categories. By analyzing data generated during the complete reviewing process, we observe: (i) how refactorings are selected, composed and evolved throughout each code change, and (ii) how developers' intents are related to these decisions. For instance, our analysis shows developers regularly apply non-trivial sequences of refactorings that crosscut multiple code elements (i.e., widely scattered in the program) to support a single feature addition. Moreover, we observed that new developers’ intents commonly emerge during the code review process, influencing how developers select and compose their refactorings to achieve the new and adapted goals. Finally, we provide an enriched dataset that allows researchers to investigate the context and motivations behind refactoring operations during the code review process.},	
  organization={ACM},
  url = {https://anderson-uchoa.github.io/publications/PaixaoAADAJA20.pdf},
  doi = {10.1145/3379597.3387475}
}

@inproceedings{SousaAECJMRA19,
  title={REM4DSPL: A Requirements Engineering Method for Dynamic Software Product Lines},
  author={Sousa, Amanda and Uchôa, Anderson and Fernandes, Eduardo and Bezerra, Carla IM and Monteiro, José Maria and Andrade, Rossana},
  booktitle={Proceedings of the XVIII Brazilian Symposium on Software Quality (SBQS), 2019, Fortaleza, Brazil, Oct 28-Nov 1},
  pages={129--138},
  year={2019},
abstract={Context: Dynamic Software Product Line (DSPL) is a set of software products capable of self-adapt and configure in run-time. DSPL products have common features (commonalities) and varying features (managed in run-time according to context changes). Objective: DSPL requirements engineering is challenging. Requirements engineers have to carefully plan self-adaptation while eliciting, modeling, and managing variability requirements. This paper introduces a method for DSPL requirements engineering. Method: We relied on empirically-derived activities of DSPL requirements engineering to build our method. We selected techniques and templates used in other domains such as SPL for refinement and incorporation into the method. We asked DSPL experts on the method applicability. Result: We introduced the Requirements Engineering Method for DSPL (REM4DSPL). Elicitation is guided by supervised discussions. Modeling relies on feature models. Variability Management is tool-assisted and validated via feature model inspection. DSPL experts agreed on the method applicability and suggested improvements. Conclusion: REM4DSPL relies on empirically-derived activities, techniques that have been successfully used by previous work, and templates adapted to the DSPL context. We expect our method to guide requirements engineers in practice.},	
  organization={ACM},
url = {https://anderson-uchoa.github.io/publications/SousaAECJMRA19.pdf},
doi = {10.1145/3364641.3364656}
}

@inproceedings{deMelloARWJKDBA19,
  title={Do Research and Practice of Code Smell Identification Walk Together? A Social Representations Analysis},
  author={Rafael de Mello and Anderson Uchôa and Roberto Oliveira and Willian Oizumi and Jairo Souza and Kleyson Mendes and Daniel Oliveira and Baldoino Fonseca and Alessandro Garcia},
  booktitle={Proceedings of the 13th International Symposium on Empirical Software Engineering and Measurement (ESEM), 2019, Porto de Galinhas, Brazil, Sept 19-20.},
  pages={1--6},
  year={2019},
abstract={Context: It is frequently claimed the need for bridging the gap between software engineering research and practice. In this sense, the theory of social representations may be useful to characterize the actual concerns of software developers. It comprises the system of values, behaviors, and practices of communities regarding a particular social object, such as the task of smell identification. Aim: To characterize the social representations of smell identification by software developers. Method: Based on the answers given to a questionnaire, we analyzed the associations made by the developers about smell identification, i.e., what immediately comes to their minds when they think about this task. Results: We found that developers strongly associate smell identification with the practice of smell removal and with the incidence of bugs. They also frequently associate the task with the practice of inspection and with the need of having individual skills. Besides, we verified that the current state of the art on smell identification partially address the social representations of the software developers. Conclusion: There is a considerable gap between the research of smell identification and its practice. We propose directions to mitigating this gap.},
publisher={IEEE Press},
url = {https://anderson-uchoa.github.io/publications/deMelloARWJKDBA19.pdf},
doi = {10.1109/ESEM.2019.8870141}
}

@inproceedings{deMelloARDWJBA2019,
  title={Investigating the Social Representations of the Identification of Code Smells by Practitioners and Students from Brazil},
  author={Rafael de Mello and Anderson Uchôa and Roberto Oliveira and Daniel Oliveira and Willian Oizumi and Jairo Souza and Baldoino Fonseca and Alessandro Garcia},
  booktitle={Proceedings of the 33nd Brazilian Symposium on Software Engineering (SBES)},
  pages={457--466},
  year={2019},
abstract={Context: The identification of code smells is one of the most subjective tasks in software engineering. A key reason is the influence of collective aspects of communities working on this task, such as their beliefs regarding the relevance of certain smells. However, collective aspects are often neglected in the context of smell identification. For this purpose, we can use the social representations theory. Social representations comprise the set of values, behaviors, and practices of communities associated with a social object, such as the task of identifying smells. Aim: To characterize the social representations behind smell identification. Method: We conducted an empirical study on the social representations of smell identification by two communities. One community is composed of postgraduate students from different Brazilian universities. The other community is composed of practitioners located in Brazilian companies, having different levels of experience in code reviews. We analyzed the associations made by the study participants about smell identification, i.e., what immediately comes to their minds when they think about this task. Results: One of the key findings is that the community of students and practitioners have stronger associations with different types of code smells. Students share a strong belief that smell identification is a matter of measurement, while practitioners focus on the structure of the source code and its semantics. Besides, we found that only practitioners frequently associate the task with individual skills. This finding suggests research directions on code smells may be revisited. Conclusion: We found evidence that social representations theory allows identifying research gaps and opportunities by looking beyond the borders of formal knowledge and individual opinions. Therefore, this theory can be considered an important resource for conducting qualitative studies in software engineering.},
publisher={ACM},
url = {https://anderson-uchoa.github.io/publications/deMelloARDWJBA19.pdf},
doi = {10.1145/3350768.3351794}
}

@inproceedings{FernandesAAA19,
  title={On the Alternatives for Composing Batch Refactoring},
  author={Eduardo Fernandes and Anderson Uchôa and Ana Carla Bibiano and Alessandro Garcia},
  booktitle={Proceedings of the 3rd International Workshop on Refactoring (IWoR)},
  pages={9--12},
  year={2019},
abstract={Code refactoring is often performed for improving code structures through code transformations. Many transformations, e.g., extracting or moving a method, are applied for at least partially removing code smells. Each code smell is a symptom of a poor code structure that makes hard to read and change the program. Developers often compose two or more interrelated transformations in conjunction (batch refactoring) rather than applying a single transformation. For instance, developers often compose method extractions with method motions to better organize the features realized by classes. We have recently observed cases of batch refactoring performed along with code review in open source projects. We then noticed that composing batches capable of fully removing code smells is quite challenging. Especially, it requires carefully discussing on how two or more transformations complement one another and what to expect from the batch effect on code smell. This position aims to reason about multiple alternatives to support developers on composing their batches. These alternatives should make it easier to compose batches that remove code smells. For this purpose, we exemplify the role of semi-automated tools in gradually recommending transformations, thereby guiding the batch composition in each alternative.},
url = {https://anderson-uchoa.github.io/publications/FernandesAAA19.pdf},
doi = {10.1109/IWoR.2019.00009},
publisher={IEEE Press}
}

@inproceedings{deMelloARDBAF19,
  title={Investigating the Social Representations of Code Smell Identification: A Preliminary Study},
  author={Rafael de Mello and Anderson Uchôa and Roberto Oliveira and Daniel Tenorio and Baldoino Fonseca and Alessandro Garcia and Fernanda de Mello},
  booktitle={Proceedings of the 12th International Workshop on Cooperative and Human Aspects of Software Engineering (CHASE)},
  pages={53--60},
  year={2019},
abstract={Context: The identification of code smells is one of the most subjective tasks in software engineering. A key reason is the influence of collective aspects of communities working on this task, such as their beliefs regarding the relevance of certain smells. However, collective aspects are often neglected in the context of smell identification. For this purpose, we can use the social representations theory. Social representations comprise the set of values, behaviors and practices of communities associated with a social object, such as the task of identifying smells. Aim: To characterize the social representations behind smell identification. Method: We conducted a preliminary study on the social representations of smell identification by two communities. One community is composed of postgraduate students involved in various investigations related to code smells. The other community is composed of practitioners from industry, with experience in code reviews. We analyzed the associations made by the study participants about smell identification, i.e., what immediately comes to their minds when they think about this task. Results: One of the key findings is that only the community of practitioners strongly associates this task with semantic smells. This finding suggests research directions on code smells may be revisited, as they focus mostly on measurable or structural smells. Considering the novelty of using the social representations theory in software engineering, we also compiled a set of lessons learned. For instance, we observed some key challenges we faced in using the theory. These challenges include: (i) the predominance of associations with technical rather than non-technical concepts, and (ii) the fuzzy definitions of key concepts in our field. Conclusion: We found initial evidence that social representations analysis is a useful instrument to reveal discrepancies and commonalities on how different communities deal with a subjective task. Thus, we expect the experience reported in this paper may encourage and contribute to future studies of social representations in the field.},
url = {https://anderson-uchoa.github.io/publications/deMelloARDBAF19.pdf},
doi = {10.1109/CHASE.2019.00022},
publisher={IEEE Press}
}

@inproceedings{UchoaEBRCGAL19,
  title={On Gamifying an Existing Healthcare System: Method, Conceptual Model and Evaluation},
  author={Anderson Uchôa and Eduardo Fernandes and Baldoino Fonseca and Rafael de Mello and Caio Barbosa and Gabriel Nunes and Alessandro Garcia and Leopoldo Teixeira},
  booktitle={Proceedings of the 1st International Workshop on Software Engineering for Healthcare (SEH)},
  pages={1--8},
  year={2019},
abstract={Software gamification aims at engaging users with software system features. User engagement is promoted via a gamification model that associates game elements (e.g., points) and rules (e.g., ranking policy) with each feature. Gamification has been increasingly explored in certain healthcare domains, such as chronic disease management and physical activity. However, there are currently two important literature gaps. First, certain healthcare domains in which user engagement is even more critical, such as the prevention of mosquito-transmitted diseases, have not systematically explored gamification yet. Healthcare systems of this domain largely depend on the wide engagement of the population, health professionals and authorities. Second, gamification is often introduced in existing systems developed without gamification in mind. Current methods are quite limited to support this task. In this paper, we report our experience while defining, incorporating, and evaluating a gamification model of an existing healthcare system called VazaZika. VazaZika is intended to assist the prevention of mosquito-transmitted diseases in economically emerging countries. We present and discuss the application of a method, adapted from a previous study, to support the design and incorporation of a gamification model in existing systems (VazaZika, in our case). We also present the resulting conceptual model based on 12 game elements and 16 rules. We evaluate this model with 20 users in terms of ease of use and potential for user engagement. Our results suggest that our conceptual model has resulted in an easy-to-use system with the potential of truly engaging users with critical healthcare-related features. We expect the method and its resulting model can be further reused and adapted to similar healthcare systems.},
url = {https://anderson-uchoa.github.io/publications/UchoaEBRCGAL19.pdf},
doi = {10.1109/SEH.2019.00009},
publisher={IEEE Press}
}

@inproceedings{JulioCA19,
 title={Analyzing the Impact of Inter-smell Relations on Software Maintainability: An Empirical Study with Software Product Lines},
author={Júlio Martins and Carla Bezerra and Anderson Uchôa},
  booktitle={Proceedings of the 15th Brazilian Symposium on Information Systems (SBSI)},
  pages={1--8},
  year={2019},
abstract={A Software Product Line (SPL) consists of a systematic reuse strategy to construct systems with less effort as long as they belong to the same family that shares the same components and belong to the same domain of Marketplace. In this context, to support large-scale reuse, components of a Software Product Line should be easy to maintain. Thus, developers should be more concerned with anomalies known as code smells and more than that, co-occurrences known as Inter-smell deserve to be further studied to verify their real impact on maintainability in SPL. Thus, this paper conducts a study to investigate the impact of Inter-smell occurrences on maintainability in MobileMedia and HealthWatcher SPLs. The results show that the presence of co-occurrences of Inter-smell did not negatively impact the maintenance of MobileMedia and Health Watcher SPLs, unlike results found in other studies in the literature, and even more, our results indicate that the metric Lack of Cohesion of Methods is one of the most important for the maintainability of object-oriented SPLs.},
url = {https://anderson-uchoa.github.io/publications/JulioCA19.pdf},
doi = {10.1145/3330204.3330254},
publisher={ACM}
}

@inproceedings{FernandesALARLDABL19,
  title={VazaZika: A Software Platform for Surveillance and Control of Mosquito-Borne Diseases},
  author={Eduardo Fernandes and Anderson Uchôa and Leonardo Sousa and Anderson Oliveira and Rafael de Mello and Luiz Paulo Barroca and Diogo Carvalho and Alessandro Garcia and Baldoino Fonseca and Leopoldo Teixeira},
  booktitle={16th International Conference on Information Technology: New Generations (ITNG)},
  pages={617--620},
  year={2019},
abstract={Mosquito-borne diseases negatively affect economically emerging countries. Nevertheless, the current public healthcare solutions are insufficient to support disease surveillance and control. The citizen engagement in reporting mosquito breeding sites is hard to achieve but essential in preventing disease outbreaks. This paper introduces the VazaZika platform aimed to support the surveillance and control of mosquito-borne diseases. This platform evolves the VazaDengue legacy platform with gamification. Through game elements and rules, we aim to make enjoyable and challenging to report mosquito breeding sites via VazaZika. Citizens are continuously rewarded as they perform tasks in the platform. They progress in levels that enable new tasks and jump in rankings according to the citizens' location. Citizens can also join teams for engaging with challenges, which helps to develop a sense of belonging and connection against the spread of diseases. This paper reports the process of gamifying VazaDengue, the platform user interface and its conceptual model, aimed to support reuse.},
url = {https://anderson-uchoa.github.io/publications/FernandesALARLDABL19.pdf},
doi = {10.1007/978-3-030-14070-0_89},
publisher={Springer}
}

@inproceedings{FerreiraIEDAAAJFGCBR18,
 author = {Ferreira, Isabella and Fernandes, Eduardo and Cedrim, Diego and Uchôa, Anderson and Bibiano, Ana Carla and Garcia, Alessandro and Correia, João Lucas and Santos, Filipe and Nunes, Gabriel and Barbosa, Caio and Fonseca, Baldoino and de Mello, Rafael},
 title = {The Buggy Side of Code Refactoring: Understanding the Relationship Between Refactorings and Bugs},
 booktitle = {Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings},
 series = {ICSE '18},
 year = {2018},
 isbn = {978-1-4503-5663-3},
 location = {Gothenburg, Sweden},
 pages = {406--407},
 numpages = {2},
abstract={Code refactoring is widely practiced by software developers. There is an explicit assumption that code refactoring improves the structural quality of a software project, thereby also reducing its bug proneness. However, refactoring is often applied with different purposes in practice. Depending on the complexity of certain refactorings, developers might unconsciously make the source code more susceptible to have bugs. In this paper, we present a longitudinal study of 5 Java open source projects, where 20,689 refactorings, and 1,033 bug reports were analyzed. We found that many bugs are introduced in the refactored code as soon as the first immediate change is made on it. Furthermore, code elements affected by refactorings performed in conjunction with other changes are more prone to have bugs than those affected by pure refactorings.},
 url = {https://anderson-uchoa.github.io/publications/FerreiraEDA18.pdf},
doi = {10.1145/3183440.3195030},
 acmid = {3195030},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {bug proneness, empirical study, refactoring, software maintenance},
}

@article{SousaLRDAPAAA18,
title = "VazaDengue: An information system for preventing and combating mosquito-borne diseases with social networks",
journal = "Information Systems",
volume = "75",
pages = "26 - 42",
year = "2018",
issn = "0306-4379",
doi = "10.1016/j.is.2018.02.003",
url = "https://anderson-uchoa.github.io/publications/SousaLRDAPAAA18.pdf",
author = "Leonardo Sousa and Rafael de Mello and Diego Cedrim and Alessandro Garcia and Paolo Missier and Anderson Uchôa and Anderson Oliveira and Alexander Romanovsky",
keywords = "Dengue, Mosquito, Social media, Surveillance, Tweets",
abstract = "Dengue is a disease transmitted by the Aedes Aegypti mosquito, which also transmits the Zika virus and Chikungunya. Unfortunately, the population of different countries has been suffering from the diseases transmitted by this mosquito. The communities should play an important role in combating and preventing the mosquito-borne diseases. However, due to the limited engagement of the population, new solutions need to be used to strengthen the mosquito surveillance. VazaDengue is one of these solutions, which offers the users a web and mobile platform for preventing and combating mosquito-borne diseases. The system relies on social actions of citizens reporting mosquito breeding sites and dengue cases, in which the reports are made available to the community and health agencies. In order to address the limited population engagement, the system proactively monitors social media network as Twitter to enrich the information provided by the system. It processes the natural language text from the network to classify the tweets according to a set of predefined categories. After the classification, the relevant tweets are provided to the users as reports. In this paper, we describe the VazaDengue features including its ability to harvest and classify tweets. Since the VazaDengue system aims to strengthen the entomological surveillance of the mosquito that transmits Dengue, Zika, and Chikungunya by providing geolocated reports, we present here two studies to evaluate its potential contributions. The first evaluation uses a survey conducted in the Brazilian community of health agents. The goal is to evaluate the relevance of the classified tweets according to the health agents’ perspective. The second study compares the official reports of the 2015–2016 epidemic waves in Brazil with the concentration of mosquito-related tweets found by VazaDengue. The goal is to verify if the concentration of tweets can be used for monitoring the mosquito manifestation in big cities. The results of these two evaluations are encouraging. For instance, we have found that the health agents tend to agree with the relevance of the classified tweets. Moreover, the concentration of tweets is likely to be effective for monitoring big cities. The results of these evaluations are helping us to improve the VazaDengue system further. These improvements will make the VazaDengue system even more useful for combating and preventing the mosquito-borne diseases."
}

@inproceedings{UchoaFBA17,
  title={Do Coupling Metrics Help Characterize Critical Components in Component-based SPL? An Empirical Study},
  author={Uchôa, Anderson and Fernandes, Eduardo and Bibiano, Ana Carla and Garcia, Alessandro},
  booktitle={Proceedings of the 5th Workshop on Software Visualization, Evolution and Maintenance (VEM'17), Fortaleza, Brazil, September 2017.},
  pages={36--43},
  year={2017},
  abstract={In component-based software product lines (SPL), each component has to encapsulate features, restrict data access, and be replaceable. For critical components, with multiple features and dependencies, these criteria are fundamental for flexible product configuration. Previous work assume that coupling metrics help characterize critical components, but we lack empirical evidence for that assumption. By characterizing critical components, we could help developers identify components that require careful maintenance and evolution. This paper relies on five well-known coupling metrics to compose a strategy for characterizing critical components in component-based SPLs. Our results suggest reasonable strategy’s accuracy but the need for using additional metrics.},
url={https://anderson-uchoa.github.io/publications/UchoaFBA17.pdf}	
}

@inproceedings{UchoaMMMC17,
author="Uchôa, Anderson G.
and Bezerra, Carla I. M.
and Machado, Ivan C.
and Monteiro, José Maria
and Andrade, Rossana M. C.",
title="ReMINDER: An Approach to Modeling Non-Functional Properties in Dynamic Software Product Lines",
bookTitle="Proceedings of the 16th International Conference on Software Reuse (ICSR'17), Salvador, Brazil, May 2017.",
year="2017",
publisher="Springer International Publishing",
pages="65--73",
abstract="This paper presents a systematic approach to modeling NFPs in DSPL feature models. In our proposed approach, feature models are annotated with the representation of NFPs, rules for the activation and deactivation of features, constraints between NFPs and features, and context adaptation scenarios. To evaluate the applicability of the proposed approach we carried out an empirical evaluation. The approach yielded good results at identifying NFPs in DSPLs.",
isbn="978-3-319-56856-0",
doi="10.1007/978-3-319-56856-0_5",
url="https://anderson-uchoa.github.io/publications/UchoaMMMC17.pdf"
}

@inproceedings{UchoaPMMC17,
author="Uchôa, Anderson G.
and Lima, Luan P.
and Bezerra, Carla I. M.
and Monteiro, José Maria
and Andrade, Rossana M. C.",
title="DyMMer-NFP: Modeling Non-functional Properties and Multiple Context Adaptation Scenarios in Software Product Lines",
bookTitle="Proceedings of the 16th International Conference on Software Reuse (ICSR'17), Salvador, Brazil, May 2017.",
year="2017",
publisher="Springer International Publishing",
pages="175--183",
abstract="In Software Product Lines (SPLs), the modeling of non-functional properties (NFPs) and context adaptation scenarios are important activities, once they make possible the identification of interdependencies constraints between functional requirements (FR) and NFP, according to a specific adaptation context scenario. However, there are few tools to help domain engineers to represent NFPs and context adaptation scenarios. To deal with this problem, we propose DyMMer-NFP, an extension of the DyMMer tool to support the modeling of NFPs and multiple contextual adaptation scenarios in feature models. DyMMer-NFP uses a catalog with 39 NFPs. Each NFP in this catalog were mapped according to each quality characteristic and sub-characteristics presented in the ISO/IEC 25010 SQuaRE product quality model. To specify the interdependencies between NFPs and features, DyMMer-NFP has used the concept of contribution links. In order to make it easier to evaluate DyMMer-NFP two datasets, called AFFOgaTO and ESPREssO, were made available for free.",
isbn="978-3-319-56856-0",
doi="10.1007/978-3-319-56856-0_12",
url="https://anderson-uchoa.github.io/publications/UchoaPMMC17.pdf"
}

@inproceedings{UchoaM16,
  title={Modelagem de Requisitos Não-Funcionais em Modelos de Features de Linha de Produto de Software Dinâmicas},
  author={Uchôa, Anderson G and Bezerra, Carla IM},
  booktitle={Proceedings of the 3rd Latin-American School on Software Engineering (ELA-ES)},
  pages={73--76},
  note={<font color="red">Best Paper Award!</font>},
  year={2016},
  abstract={This paper proposes a representation of non-functional requirements and context requirements for the feature model of DSPLs. The   representation extends the FODA notation of the feature model. The proposal will be implemented in DyMMer tool that already provides representation of features and context adaptations in a single feature model.},
 url={https://anderson-uchoa.github.io/publications/UchoaM16.pdf}
}

@misc{UchoaR16,
  author={Anderson Gonçalves Uchôa},
  title={ReMINDER: Uma Abordagem para Modelagem de Propriedades Não-Funcionais em Linhas de Produto de Software Dinâmicas},
  note={BSc Thesis, Federal University of Ceará (UFC)},
  year={2016},
  abstract = {Linhas de Produto de Software (LPS) representam um conjunto de sistemas de software que compartilham de um conjunto de features comuns e gerenciadas, que satisfazem as necessidades de um segmento de mercado particular ou missão. No entanto, a representação de variabilidade dos produtos gerados por LPSs é feita apenas de forma estática, ou seja, a adaptação ocorre em tempo de projeto. Contudo, com o surgimento de sistemas sensíveis ao contexto, a construção de sistemas tem se tornado mais complexa, dado as mudanças de requisitos e restrições conforme o ambiente no qual está inserido, exigindo um alto grau de adaptação em tempo de execução. Esses sistemas podem ser conceitualizados como Linhas de Produtos de Software Dinâmica (LPSD). Um dos desafios para construir um LPSD é desenvolver um mecanismo para incorporar cenários com adaptações de contexto e propriedades não-funcionais (PNFs). Para incorporar esses mecanismo ao modelo de features de LPSDs, uma boa estratégia consiste em utilizar uma abordagem para guiar a identificação e representação destes mecanismos. Neste cenário, o objetivo deste trabalho é representar PNFs e cenários de adaptações de contexto em modelos de features de LPSDs. Para isso, foi elaborada uma abordagem capaz de identificar PNFs, restrições e cenários de adaptações de contexto, ativação e desativação de features, denominada ReMINDER. Também foi desenvolvida uma extensão da ferramenta DyMMer, para suportar a abordagem. Para avaliação da abordagem e da ferramenta, foram realizados dois estudos. O primeiro foi um experimento controlado, para analisar o processo definido na abordagem ReMINDER, com a finalidade de caracterizar a sua aplicação, em relação à identificação de PNFs e cenários de adaptações de contexto, com suas respectivas restrições, para apoiar a modelagem de features e representação de PNFs em modelos de features de LPSDs. O segundo estudo foi a aplicação de um teste de usabilidade. Esse teste teve como objetivo avaliar a usabilidade da ferramenta estendida por meio da análise de quatro fatores: i) satisfação geral; ii) usabilidade da ferramenta; iii) qualidade da informação; e iv) qualidade da interface. De modo geral, após a análise e interpretação de todos os resultados obtidos, conclui-se que a abordagem auxiliou na identificação das PNFs e a sua relação com o comportamento do modelo de features por meio de restrições de interdependência. Além disso, também foi verificado que a ferramenta estendida possui um boa usabilidade, sendo útil para operacionalização da abordagem.},
  url={https://anderson-uchoa.github.io/publications/UchoaR16.pdf},
  doi = {http://www.repositorio.ufc.br/handle/riufc/24885}
}
